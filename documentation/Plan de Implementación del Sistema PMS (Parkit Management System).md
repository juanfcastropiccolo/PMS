# <a name="header"></a><a name="content"></a><a name="x4539b500984954c06213fdb2c632cd5d77b8e5a"></a>Plan de Implementación del Sistema PMS (Parkit Management System)
## <a name="objetivos-y-alcance-del-pms"></a>Objetivos y Alcance del PMS
El **Parking Management System (PMS)** será una aplicación web de administración diseñada para complementar la app móvil de Parkit. Permitirá gestionar el *marketplace* de estacionamientos privados/comerciales, brindando a los dueños de estacionamientos y al equipo interno de Parkit las herramientas necesarias para operar la plataforma. En esencia, esta web actuará como el portal administrativo donde propietarios pueden **“subir” y administrar sus cocheras** y el equipo de Parkit puede supervisar y aprobar contenido[\[1\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Este%20nuevo%20sistema%20web%20actuar%C3%A1,analizado%20y%20los%20objetivos%20mencionados)[\[2\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=En%20esencia%2C%20esta%20aplicaci%C3%B3n%20web,de%20cada%20parking%20por%20desarrolladores).

- **Usuarios objetivo:** El PMS será utilizado tanto por **dueños de estacionamientos afiliados** (usuarios que crean cuenta para ofrecer sus cocheras o playas de estacionamiento privadas) como por **empleados internos de Parkit** (equipos de Desarrollo u Operaciones que requieren funciones de administración global)[\[2\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=En%20esencia%2C%20esta%20aplicaci%C3%B3n%20web,de%20cada%20parking%20por%20desarrolladores). La aplicación móvil Parkit continuará siendo utilizada por los conductores (Parkers) y spotters para la experiencia de búsqueda y reporte de estacionamientos, mientras que la web cubrirá las necesidades de gestión para propietarios y administración interna[\[2\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=En%20esencia%2C%20esta%20aplicaci%C3%B3n%20web,de%20cada%20parking%20por%20desarrolladores). En otras palabras, los conductores y spotters **no necesitan usar el PMS**.
- **Alcance (Free vs. Privado):** El PMS abarcará **exclusivamente la gestión de estacionamientos privados/comerciales** del marketplace. Los estacionamientos *“free”* (gratuitos en la vía pública reportados por la comunidad) se manejan íntegramente desde la app móvil y **no requieren interfaz web de administración**, pues no tienen un “dueño” que los administre. Por lo tanto, el PMS se centrará en funciones como altas de estacionamientos privados, control de disponibilidad, reservas y pagos del marketplace, y no en los spots públicos comunitarios (aunque debe considerarse la interacción entre ambos tipos en la plataforma global[\[3\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=reservas%2C%20pagos%2C%20etc,brindar%20a%20todos%20los%20actores)). Esta separación garantiza que el equipo Parkit pueda escalar el marketplace eficientemente sin distraerse con la información de estacionamiento gratuito que ya está cubierta por la comunidad vía la app móvil.

En resumen, el objetivo del PMS es **proveer una plataforma robusta para escalar la oferta de estacionamientos privados** en Parkit, permitiendo a los propietarios gestionar sus espacios y al staff de Parkit mantener la calidad y seguridad del marketplace. A continuación, se describe la pila tecnológica propuesta y las funcionalidades clave a implementar.
## <a name="pila-tecnológica-recomendada-stack"></a>Pila Tecnológica Recomendada (Stack)
Para asegurar un desarrollo ágil, mantenible y con buen desempeño, se propone usar un stack web moderno, seleccionando tecnologías adecuadas para frontend, backend y base de datos:

- **Frontend:** Se recomienda construir la interfaz con **React** y **TypeScript**, idealmente usando un framework como **Next.js**. Next.js ofrece una estructura modular, SSR/SSG cuando sea útil y fácil integración con APIs, lo que encaja bien con un panel administrativo. React + TS proporcionará componentes reutilizables y type-safety para reducir errores. Además, existen muchas librerías UI (por ejemplo **Material-UI (MUI)** o **Ant Design**) que podrían acelerar la creación de componentes comunes (tablas, formularios, cuadros de diálogo) con un diseño consistente.
- **Backend y Base de Datos:** Aprovecharemos el backend ya existente de Parkit basado en **Supabase (PostgreSQL)**, de modo que la web PMS comparta la misma base de datos en tiempo real que la app móvil[\[4\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Al%20conectar%20esta%20web%20al,el%20due%C3%B1o%20en%20su%20panel). Supabase provee autenticación, almacenamiento de archivos y suscripciones en tiempo real out-of-the-box, lo cual facilita sincronizar datos entre la app y el PMS sin tener que construir servidores desde cero. Todas las **operaciones CRUD** (crear estacionamiento, actualizar disponibilidad, leer reservas, etc.) se realizarán a través de la API de Supabase o sus SDK, respetando las políticas de seguridad definidas (RLS). Esto garantiza que, por ejemplo, cuando un dueño actualice datos desde el PMS, los conductores lo vean reflejado inmediatamente en el mapa de la app[\[4\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Al%20conectar%20esta%20web%20al,el%20due%C3%B1o%20en%20su%20panel), y viceversa (reservas hechas por conductores aparecerán al instante en el panel del propietario).
- **Lógica de Servidor (Funciones Serverless):** Si bien gran parte de la lógica de negocio puede manejarse con llamadas directas a Supabase, para ciertas tareas sensibles utilizaremos funciones de backend. Dos opciones viables son: **API Routes de Next.js** (endpoints serverless incluidos en el mismo proyecto) o **Supabase Edge Functions** (funciones serverless en Deno desplegadas junto al backend). Estas se usarán para casos como: manejo seguro de la autenticación OAuth de Mercado Pago (intercambio de tokens con secretos), procesamiento de webhooks de pago/confirmación de reservas, envío de correos de notificación, etc. Por ejemplo, implementaremos una función serverless para procesar la respuesta de **OAuth de Mercado Pago**, de modo que el *client secret* no se exponga en el frontend y los tokens de acceso se almacenen de forma segura en la base de datos del propietario.
- **Autenticación y Seguridad:** Utilizaremos el sistema de **Auth de Supabase** ya en uso por Parkit, asegurando que los usuarios puedan iniciar sesión en el PMS con las mismas credenciales de la app móvil. Para distinguir roles (propietario vs admin Parkit) se aprovecharán los mecanismos de Auth (como claims JWT custom o tablas de roles). La comunicación entre el frontend y Supabase será asegurada vía SSL y los JWT de sesión. Adicionalmente, las [Reglas RLS](https://supabase.com/docs/learn/auth-deep-dive/auth-row-level-security) se configuran para que cada usuario autenticado **solo pueda acceder a sus datos** (p. ej., un dueño solo ve sus propios estacionamientos, reservas y pagos), mientras que los admins tendrán permisos para ver datos de todos los estacionamientos (ver sección de Roles más abajo).
- **DevOps y Hosting:** El frontend (Next.js) se puede desplegar en plataformas serverless modernas (como **Vercel** u **Netlify**) para obtener CI/CD integrado. Supabase ya hospeda la base de datos y sus servicios administrados, facilitando la escala. Se mantendrán entornos separados (dev/staging/prod) para pruebas. El repositorio del PMS estará separado del repo móvil, pero ambos proyectos compartirán ciertos recursos (como definiciones de tablas de la base). Se versionarán migraciones de DB a través de la CLI de Supabase para agregar campos o tablas adicionales necesarias (ej: estructura de pisos, vista de disponibilidad, etc. – ver más abajo).

En conjunto, este stack ofrece **rapidez de desarrollo** (gracias a React y servicios gestionados), **integración en tiempo real** (Supabase) y **seguridad** desde el día uno (Auth con RLS). Ahora, detallaremos cómo se manejarán los distintos roles de usuario y posteriormente las funcionalidades específicas a desarrollar.
## <a name="roles-de-usuario-y-control-de-acceso"></a>Roles de Usuario y Control de Acceso
Habrá dos roles principales en el PMS, con distintos privilegios y vistas en la aplicación:

- **Propietario de Estacionamiento (Usuario Externo):** corresponde a cualquier usuario de Parkit que haya creado su cuenta para ofertar un estacionamiento en el marketplace. Este rol puede **cargar y gestionar únicamente sus propios estacionamientos y reservas**. El sistema debe impedir que un propietario acceda o modifique datos de estacionamientos ajenos[\[5\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=match%20at%20L390%20ver%2Feditar%20sus,62). Esto se logrará mediante *Row-Level Security* en la base de datos (políticas Supabase que filtran registros por propietario\_id = auth.uid(), ya implementadas en tablas como estacionamientos, reservas, etc.) y también mediante validaciones en el frontend (ocultando o bloqueando vistas no permitidas). Un propietario típico podrá: crear/editar la información de su cochera, ver las reservas hechas en ella, actualizar disponibilidad, vincular su cuenta de pago, etc., pero **no** podrá ver estacionamientos de otros dueños ni acceder a funciones administrativas globales.
- **Administrador Parkit (Usuario Interno):** corresponde al staff interno (empleados de Desarrollo/Operaciones) con permisos ampliados. Los administradores pueden **ver y gestionar todos los datos de la plataforma**: aprobar o rechazar nuevos estacionamientos registrados, revisar y validar documentos KYC, observar todas las reservas realizadas, modificar listados si fuera necesario, y obtener métricas globales. Este rol actuará sobre datos globales, por lo que sus consultas no deben filtrarse por user\_id. Implementaremos este acceso de dos posibles formas (no excluyentes):
- *Via Supabase:* Definir un atributo de JWT (por ejemplo role: 'admin') que podamos asignar manualmente a ciertas cuentas, y luego añadir excepciones en las políticas RLS para ese rol. Por ejemplo, en la tabla estacionamientos una política podría permitir select a admins sin restricción.
- *Via API secreta:* Alternativamente, las páginas o servicios del PMS que requieran datos globales podrían emplear la *Service Key* de Supabase (que ignora RLS) en un entorno seguro (funciones serverless), devolviendo al frontend solo la información necesaria. Esto agrega seguridad adicional ya que la lógica administrativa residiría en backend.

En la práctica, utilizaremos la primera opción para simplicidad – marcando administradores en la base (p.ej. un campo is\_admin en la tabla de usuarios o en los app\_metadata de Supabase) y adaptando las políticas. De cualquier manera, la **UI mostrará diferentes secciones según el rol**: los propietarios verán su panel de negocio, mientras que los admins verán además herramientas de moderación y un dashboard global. Al iniciar sesión, el PMS detectará el tipo de usuario y redirigirá o mostrará las opciones correspondientes (por ejemplo, un admin podría ver un menú extra de "Administración" con sub-secciones de gestión).

**Registro de cuentas:** Los propietarios se registrarán como usuarios normales de Parkit (esto ya ocurre en la app móvil). No habrá un proceso de registro separado solo por ser propietario; cualquier usuario que decida “subir su estacionamiento” simplemente completará verificaciones adicionales (KYC, etc.) pero sigue siendo el mismo usuario en la tabla de autenticación. En cambio, para distinguir a un admin, lo marcaremos manualmente (p.ej. ajustar un flag en la base de datos o invitarlo por backend). El sistema PMS deberá reconocer esos flags.

**Sesiones y autenticación integrada:** Gracias a Supabase, los usuarios podrán iniciar sesión en la web PMS usando su email/contraseña (o método que utilice Parkit, p. ej. OAuth con Google si estuviera habilitado) y se respetarán las mismas credenciales. Una vez autenticado, el frontend obtendrá un JWT que incluirá la información de user\_id y posiblemente el claim de rol. Ese token se usará en todas las llamadas a Supabase. Así mantenemos una experiencia unificada: un propietario puede loguearse tanto en la app móvil como en la web con la misma cuenta.

En síntesis, el control de acceso se apoyará en **RLS** y lógica de frontend para asegurar que cada quien vea solo lo que debe. La distinción de roles es fundamental ya que define prácticamente dos sub-aplicaciones dentro del PMS (la vista del **Dueño** y la vista del **Admin**).
## <a name="x349fdcff994a7d076326b99dbee4f56f1cd63ff"></a>Funcionalidades para Propietarios (Portal de Dueños)
Este apartado resume las características que ofrecerá el PMS a los propietarios para administrar sus estacionamientos privados. Todas estas funcionalidades están orientadas a que un dueño pueda operar su estacionamiento dentro de Parkit de forma independiente.

- **Registro y Edición de Estacionamientos:** La plataforma permitirá a los propietarios **dar de alta un nuevo estacionamiento** en la plataforma (si no lo hicieron ya desde la app móvil) y editar los detalles de los que ya tengan. Esto incluye un **formulario completo de datos** donde se capturarán: nombre comercial, dirección exacta (con posible integración de auto-completar de Google Places), horarios de apertura/cierre, precio por hora, tipo de estacionamiento (categoría: cochera privada, playa comercial, etc.), capacidad total de vehículos y características del lugar (altura máxima, si es cubierto, si tiene seguridad, cargador para vehículos eléctricos, etc.)[\[6\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Registro%20y%20perfil%20de%20estacionamiento%3A,de%20ah%C3%AD%20el%20campo%20verificado). También se podrán **subir fotos** del estacionamiento (idealmente mínimo 3 imágenes) para mostrar a los usuarios la entrada, plazas, cartelería, etc. – estas fotos se almacenarán en Supabase Storage (bucket estacionamientos ya previsto) siguiendo la estructura por usuario/parking, con políticas que permiten verlas públicamente[\[7\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L82-L91)[\[8\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L94-L101).
- *Estado y verificación:* Cuando un propietario crea un nuevo listing, inicialmente quedará en estado **"Pendiente" o Inactivo**, a la espera de aprobación por parte de Parkit. Esto ya está contemplado en el modelo de datos existente (campos activo: false, verificado: false al crear)[\[9\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L160-L168). El PMS reflejará claramente este estado (por ejemplo, mostrando un badge “En revisión” en el dashboard del dueño). El dueño podrá ver el estado de cada estacionamiento que registró (Pendiente, Aprobado/Verificado, Rechazado)[\[10\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L48-L52)[\[11\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L231-L239). Si es **rechazado**, habría que mostrar el motivo o instrucciones para corregir y volver a enviar. Una vez **aprobado**, el estacionamiento pasa a activo en la app (visible a conductores) – el dueño podría entonces tener la opción de **activar/desactivar** temporalmente el listing desde el PMS (por ejemplo, un switch “publicar/pausar” que cambie el campo activo, útil si necesita cerrar por refacciones, etc., sin perder la verificación)[\[12\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L168-L171).
- *Multi-establecimiento:* En caso de que un mismo usuario administre múltiples estacionamientos (p. ej., una cadena de cocheras), la interfaz soportará listado múltiple. Habrá una sección "Mis Estacionamientos" mostrando todos los que el usuario registró[\[13\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L225-L234), cada uno con su información resumida (nombre, dirección, precio, estado, etc.) y acceso a editar detalles individuales. Desde allí también podrá agregar nuevos estacionamientos con un botón tipo “Agregar estacionamiento” (FAB o similar)[\[14\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L187-L194).
- **Mapa de Plazas y Niveles:** Para representar mejor la capacidad del estacionamiento, el PMS incorporará una forma de **modelar la estructura de plazas**. Inicialmente, implementaremos un enfoque sencillo en el formulario de registro: el dueño podrá especificar el número de **pisos/niveles** que tiene su parking y cuántas plazas por piso (o la capacidad total)[\[15\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Mapa%20de%20plantas%20y%20espacios%3A,aunque%20eso%20es%20bastante). Esto podría capturarse con campos como "Cantidad de pisos" y "Capacidad por piso" (ej. una lista de números por nivel) o simplemente "Capacidad total" si no se quiere detallar por niveles en MVP. Dado que a futuro Parkit quiere mostrar a los conductores en qué nivel hay lugares disponibles, conviene almacenar esta estructura ahora aunque sea de forma básica[\[16\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Esto%20podr%C3%ADa%20ser%20sencillo%20,aunque%20eso%20es%20bastante). Por simplicidad, podríamos guardar en la BD un JSON o campos adicionales para distribución por pisos. *Ejemplo:* Piso 1: 50 plazas, Piso 2: 50 plazas, etc. En versiones futuras, se podría ofrecer una **interfaz visual** más avanzada (un mapa tipo grid para dibujar cada plaza y distinguir ocupadas/libres), pero en un primer release lo manejaremos textualmente[\[17\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=planea%20mostrar%20hasta%20qu%C3%A9%20nivel,aunque%20eso%20es%20bastante).

Además, el PMS debe permitir al propietario **actualizar la disponibilidad en tiempo real**. Si no existe una integración automática con sensores en el estacionamiento, proveeremos una función manual: por ejemplo, un botón *"Actualizar ocupación"* o campos donde el dueño ingresa cuántos espacios libres hay en cada momento[\[18\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Actualizaci%C3%B3n%20de%20disponibilidad%3A%20Si%20no,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime). Esto actualizará un contador de plazas disponibles (posiblemente en la tabla o vista estacionamientos\_disponibles que ya calcula espacios libres según reservas activas)[\[19\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=match%20at%20L292%20la%20DB,tiene%20un%20registro%20rico%20en). Aunque no es la solución óptima a largo plazo, sirve como paso intermedio[\[18\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Actualizaci%C3%B3n%20de%20disponibilidad%3A%20Si%20no,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime). Más adelante, con integraciones tipo **IZI Park** u otros hardware de conteo, estos datos podrían actualizarse automáticamente[\[20\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=en%20cada%20momento%20,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime), pero desde el día uno nos aseguraremos de tener el mecanismo manual. Importante: cada vez que el propietario informe un cambio de disponibilidad, el PMS lo escribirá en la base y gracias a Supabase *realtime* esa información se propagará instantáneamente a la app móvil para que los conductores vean el nuevo número de espacios libres[\[21\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=intermedio%20podr%C3%ADa%20funcionar,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime). Esto mantiene sincronizados a ambos públicos.

- **Gestión de Reservas:** Una funcionalidad crucial será mostrar al propietario las **reservas realizadas** en su estacionamiento a través de Parkit. En un apartado tipo "Mis Reservas" (dentro del estacionamiento específico o global si maneja varios), el dueño podrá ver la lista de reservas **pendientes y confirmadas** para fechas futuras[\[22\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Gesti%C3%B3n%20de%20reservas%3A%20El%20propietario,57%5D%2C%20vinculada%20a%20su%20estacionamiento). Por cada reserva se mostrará información relevante: nombre del usuario conductor (o alias), horario/fecha de la reserva (ej. inicio y fin), código de reserva o QR (si se implementa), estado del pago, y cualquier otro detalle necesario (por ejemplo, si la reserva fue prepagada vía Mercado Pago, debería indicarse). Esta vista le permite al operador del estacionamiento **validar la entrada**: por ejemplo, al llegar un conductor, podría pedirle el código de reserva y marcarla como *"check-in realizado"* en el sistema.

También habilitaremos acciones de administración de reservas: el propietario debería poder **marcar no-shows o cancelar reservas** si el cliente no se presenta o a solicitud del mismo[\[22\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Gesti%C3%B3n%20de%20reservas%3A%20El%20propietario,57%5D%2C%20vinculada%20a%20su%20estacionamiento). Al marcar una reserva como no-show (no presentada), esto podría liberar el espacio y registrarse para posibles reembolsos (la política de no-show se definiría, pero al PMS le compete registrar el evento). Si cancela una reserva (antes de su inicio, por ejemplo), idealmente se avisaría al usuario y se gestionaría la devolución según corresponda. Estas acciones estarán disponibles con confirmación para evitar errores.

Además de la lista, sería útil una **vista tipo calendario** para el propietario, donde pueda visualizar en un calendario las reservas futuras (por día/semana). Esto ayuda a administrar la ocupación de manera visual, especialmente si el estacionamiento recibe muchas reservas. No es imprescindible para un MVP, pero de fácil implementación usando librerías de calendario una vez que la data de reservas está accesible.

*Nota:* Toda la información de reservas proviene de la tabla reservas en la base de datos, vinculada al estacionamiento por su ID[\[22\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Gesti%C3%B3n%20de%20reservas%3A%20El%20propietario,57%5D%2C%20vinculada%20a%20su%20estacionamiento). Aseguraremos que las consultas filtren por propietario\_id = auth.uid() en join con estacionamientos, para que cada dueño solo obtenga sus reservas. En caso de que la tabla de reservas no tenga directamente el propietario, se unirá vía estacionamiento -> propietario.

Futuramente, podríamos generar automáticamente **códigos QR o PINs** únicos para cada reserva, que el conductor muestre al llegar y el operador escanee o ingrese en el PMS para confirmar ingreso[\[23\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Gesti%C3%B3n%20de%20reservas%3A%20El%20propietario,o%20cancelar%20reservas%20si%20es). Esto brindaría más seguridad y un check-in rápido. Para la primera versión, quizás se use un código alfanumérico simple visible en la reserva.

- **Integración de Pagos y Finanzas:** Dado que Parkit facilita pagos electrónicos por las reservas, el PMS debe permitir a los dueños gestionar la **cobranza de sus ingresos**. En concreto:
- Se integrará la funcionalidad de **autenticación OAuth de Mercado Pago** para que cada propietario vincule su cuenta de Mercado Pago con Parkit[\[24\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Finanzas%20y%20pagos%3A%20Integrar%20la,ser%C3%ADa%20%C3%BAtil%20para%20la%20administraci%C3%B3n). Esta etapa ya se inició en la app móvil (posiblemente muchos propietarios conecten su cuenta desde allí); sin embargo, desde el PMS también se ofrecerá, ya que algunos dueños preferirán hacer todo desde la web. El flujo consistirá en redirigir al usuario al OAuth de Mercado Pago, y al retornar, intercambiar el código por tokens de acceso/refresh mediante una función serverless segura, almacenando esos tokens (y el mercadopago\_user\_id) en la base de datos (tabla vendedores o campos del estacionamiento)[\[25\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=match%20at%20L384%20las%20reservas,est%C3%A1). Una vez vinculado, el estado de conexión se mostrará en el perfil (ej. “Cuenta MercadoPago: Conectada ✅” o “No conectada ⚠️”).
- El PMS incluirá un **Panel de Ingresos** donde el propietario pueda ver un resumen de sus ganancias generadas a través de la plataforma. Por ejemplo: total acumulado, cuánto fue pagado en el último mes, comisión de Parkit descontada, etc.[\[24\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Finanzas%20y%20pagos%3A%20Integrar%20la,ser%C3%ADa%20%C3%BAtil%20para%20la%20administraci%C3%B3n). También listaremos las transacciones o reservas completadas con detalles de monto pagado por el usuario y neto recibido por el dueño. Esto se obtiene de la tabla de reservas/pagos; cada reserva podría tener un monto y quizás un status de pago. Si hay una tabla de *pagos* separada o un registro de transacciones de MercadoPago, se integrará la consulta. El objetivo es que el dueño tenga transparencia sobre su negocio dentro de Parkit.
- Podrían incorporarse opciones como **facturación** o comprobantes: por ejemplo, que pueda descargar un reporte mensual de todas sus reservas para contabilidad. Inicialmente, mostrar los datos en pantalla será suficiente, pero es bueno prever la exportación a CSV/PDF de la lista de reservas e ingresos.
- También se considerará la posibilidad de que el propietario invoque un retiro manual; sin embargo, si Mercado Pago está vinculado, en teoría el dinero va automáticamente a su cuenta MP tras cada pago menos la comisión de Parkit. Aun así, el panel clarificará “Comisión del X% aplicada por Parkit” para cada transacción.
- **Calificaciones y Feedback:** Parkit permite que los conductores califiquen el estacionamiento después de usarlo (y dejen reseñas). Por ello, el PMS mostrará al dueño un resumen de **sus reseñas y rating promedio**. En la sección de su estacionamiento, verá por ejemplo “⭐️ 4.5 (basado en 10 reseñas)” y podrá leer comentarios de usuarios (almacenados en la tabla resenas o equivalente)[\[26\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Dashboard%20y%20m%C3%A9tricas%3A%20El%20PMS,propietario%20pueda%20mejorar%20su%20servicio). Esto ayuda a que el dueño obtenga feedback y pueda mejorar su servicio. Si alguna reseña es injusta o viola términos, el dueño podría reportarla al admin, pero al menos debe poder visualizarlas. (El reporte sería un flujo manual inicialmente, quizás vía contacto con soporte, dado que implementar moderación de reviews podría ser complejo de momento).
- **Dashboard de Propietario (Métricas):** Además de las funciones operativas, al propietario se le ofrecerá un **dashboard** general con métricas clave de su estacionamiento[\[26\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Dashboard%20y%20m%C3%A9tricas%3A%20El%20PMS,propietario%20pueda%20mejorar%20su%20servicio). En esta vista de inicio (al hacer login, si es propietario) se podrían mostrar indicadores como:
- Cantidad de reservas recibidas esta semana/mes.
- Tasa de ocupación promedio (porcentaje del tiempo que sus plazas estuvieron ocupadas via reservas; esto se puede calcular sobre horas pico, etc.).
- Ingresos generados en el mes actual.
- Calificación promedio actual.
- Número de usuarios de Parkit que han visitado su estacionamiento (únicos).

Gráficos simples (ej. una gráfica de barras de reservas por día en la última semana, o ingresos por mes) darían valor añadido visual. Estas estadísticas se pueden calcular en consultas agregadas a la BD. Si la cantidad de datos empieza a ser grande, se podría crear vistas materializadas o endpoints especializados para eficiencia, pero inicialmente con las tablas de reservas y reseñas alcanza.

- **Notificaciones y Comunicaciones:** El sistema enviará notificaciones al propietario en eventos importantes. Ejemplos:
- **Aprobación/Rechazo de Estacionamiento:** cuando el staff de Parkit revise su solicitud, el dueño debería recibir un correo electrónico indicando si fue aprobado (y ya está activo) o rechazado (con motivo). Esto puede implementarse usando funciones de Supabase (triggers que detecten cambio de estado y envíen correo vía SMTP configurado) o con una función serverless que el admin dispare al hacer clic en "Aprobar".
- **Nueva Reserva:** opcionalmente, se podría enviar un email o notificación push al dueño cada vez que alguien reserva en su cochera (incluyendo detalles básicos y recordatorio de verificar en su panel). Dado que la app móvil originalmente no estaba pensada para dueños (más para conductores), tal vez los propietarios dependan del PMS/email para enterarse de reservas. Evaluaremos integrar **notificaciones push** a la app Parkit para dueños (si el dueño tiene la app, podría recibir una push "Has recibido una nueva reserva"), reutilizando el sistema de notificaciones existente para Parkers pero filtrando por rol.
- **Recordatorios:** por ejemplo, si una reserva está próxima (en 1 hora), enviar aviso al dueño para prepararse. Esto sería un nice-to-have que podríamos implementar más adelante mediante cron jobs o supabase scheduled functions.

Todas estas funcionalidades buscarán que el dueño pueda operar su estacionamiento en la plataforma **de forma autónoma y en tiempo real**, sin necesidad de asistencia manual de Parkit para tareas cotidianas. Esto habilita la **escalabilidad**: cientos de estacionamientos pueden ser administrados simultáneamente por sus dueños mediante el PMS.
## <a name="x28d232d41fa50cf9d3e52b99b9ae9ed8f8a2592"></a>Funcionalidades para Administradores (Portal Interno Parkit)
El PMS también ofrecerá un conjunto de herramientas para los **administradores internos de Parkit**, enfocadas en la moderación de contenidos, soporte y visión global del negocio. A continuación las principales funciones del rol admin:

- **Revisión y Aprobación de Nuevos Estacionamientos:** Una de las tareas iniciales del equipo de Operaciones será validar los estacionamientos que los usuarios carguen. El PMS proveerá un **módulo de moderación** donde se listan todas las **solicitudes pendientes de aprobación**. Cada entrada mostrará el nombre del estacionamiento, el tipo (privado, comercial, etc.), los datos del propietario (nombre, email) y la fecha de solicitud. Al seleccionar una solicitud, el admin podrá ver **todos los detalles provistos por el usuario** durante el registro, incluyendo los documentos KYC y fiscales adjuntados:
- Datos personales (nombre completo, DNI, dirección) y fotos de DNI/selfie, en caso de cocheras privadas[\[27\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L24-L32)[\[27\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L24-L32).
- Datos fiscales (CUIT, razón social, constancia AFIP) para estacionamientos comerciales[\[28\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L26-L34).
- Información del estacionamiento: dirección, capacidad, fotos del lugar, etc.
- Estado actual (Pendiente).

Desde esta vista, el administrador tendrá botones para **Aprobar** o **Rechazar** la solicitud. Al aprobar, el PMS debe realizar varias acciones en cascada: - Marcar el estacionamiento como verificado = true (y posiblemente activo = true si todo está correcto) en la tabla estacionamientos. - Actualizar el registro KYC correspondiente a aprobado. - Si es primera vez, quizás enviar un email automático al usuario notificando la aprobación. - Si hay un flujo de depósito de garantía o algo similar, coordinarlo (no mencionado por ahora, así que probablemente no).

En caso de **rechazo**, el admin debería poder ingresar un motivo (ej: "La foto del DNI no es legible" o "La dirección es inválida"). Este motivo se puede enviar al usuario para que corrija. Podríamos manejar rechazos cambiando el estado a rechazado tanto en estacionamiento como en KYC, y permitir al usuario editar y reenviar la solicitud (o cargar nuevos documentos).

Para agilizar, podríamos implementar **filtros** en esta sección (ver solo pendientes, o buscar por nombre/usuario) y paginación si hubiera muchas solicitudes. Esta funcionalidad es prioritaria para lanzar el marketplace de manera confiable, ya que **garantiza la calidad** de los estacionamientos publicados.

- **Gestión de Estacionamientos Existentes:** Además de aprobar nuevos, el admin tendrá acceso a una lista de **todos los estacionamientos** en la plataforma. Esto sirve para:
- Ver cuántos están activos, cuántos pausados, cuántos rechazados, etc.
- Intervenir si es necesario: por ejemplo, dar de baja un estacionamiento que recibió muchas quejas, o editar información incorrecta (en caso de soporte al propietario).
- Ver el detalle de cada estacionamiento (similar a como lo ve el dueño, pero con permisos totales).

Una funcionalidad útil aquí sería permitir al admin **impersonar** al propietario temporalmente para ver exactamente lo que él ve o incluso hacer cambios en su nombre (aunque esto último con cuidado). Si no, al menos un botón "Editar" que habilite campos editables de ese estacionamiento en la interfaz admin.

También, desde la lista de estacionamientos, se podría marcar manualmente alguno como verificado o activo/inactivo. Esto podría ser necesario si, por ejemplo, un estacionamiento previamente aprobado empieza a incumplir normas y se decide suspenderlo (desactivar su publicación) – el admin podría cambiar activo a false y quizás notificar al dueño.

- **Supervisión de Reservas y Usuarios:** El panel admin también ofrecerá vistas globales de **reservas** y **usuarios**:
- **Reservas:** Una tabla de todas las reservas realizadas en el sistema, con posibilidad de filtrar por estacionamiento, por fecha, por estado (pendiente, completada, cancelada). Esto ayuda a soporte a buscar reservas específicas si un usuario o dueño plantea un problema (“no me llegó el pago de la reserva X”, “quiero cancelar la reserva Y manualmente”, etc.). Desde aquí el admin podría forzar cancelaciones o modificaciones en casos excepcionales (por ejemplo, reembolsar a un cliente si hubo un problema, lo que implicaría coordinación con Mercado Pago fuera de la plataforma principal).
- **Usuarios:** Lista de usuarios registrados, donde se pueda ver quiénes son propietarios (los que han creado estacionamientos) y quizás datos agregados como cantidad de estacionamientos publicados por cada uno, o si completaron KYC. Esto es útil para el equipo de Parkit para saber cuántos propietarios activos hay, contactar alguno si es necesario, etc. No implementaremos funcionalidades de CRM complejas, pero al menos visualizar la información básica y poder buscar usuarios por email.
- **Dashboard Global y Métricas:** Al nivel más alto, los administradores querrán ver el desempeño general de la plataforma. Proporcionaremos un **Dashboard de métricas globales** que muestre:
- Número total de estacionamientos en el marketplace, subdividido en activos, pendientes, rechazados.
- Cantidad de nuevas solicitudes de estacionamiento esta semana/mes.
- Número total de reservas realizadas a través de la plataforma (y posiblemente cuántas completadas exitosamente vs canceladas).
- Ingresos totales procesados vía la plataforma en un periodo (y de esos, cuánto fue comisión para Parkit). Por ejemplo, "Este mes se procesaron ARS $500k en pagos, de los cuales $50k son comisiones de Parkit".
- Crecimiento de la base de usuarios (cuantos nuevos conductores, cuantos nuevos propietarios).
- Otros KPIs relevantes: promedio de rating global, etc.

Estos datos permiten al equipo evaluar la salud del negocio y preparar informes para inversores o para ajustar estrategias. El dashboard puede incluir gráficos de tendencia (por ej., reservas mensuales en el último año). Mucha de esta info sale de las mismas tablas pero a nivel agregado; se pueden usar funciones SQL (COUNT, SUM) o crear vistas materializadas para eficiencia. *Ejemplo:* una vista de ingresos mensuales por estacionamiento para graficar evolución.

- **Herramientas de Soporte:** Podríamos agregar utilidades para el equipo de soporte, como:
- **Aprobación de reseñas/reportes:** Si en el futuro se modera contenido de reseñas o si los usuarios pueden reportar estacionamientos o spots fraudulentos, aquí sería donde el admin las revisa. (Actualmente no especificado, pero es un posible módulo).
- **Gestión de contenido estático:** por ejemplo, actualizar términos y condiciones visibles en la app, o enviar notificaciones globales. Sin embargo, esto es secundario y podría manejarse fuera del PMS en el corto plazo.
- **Logs y Auditoría:** Para confianza y debugging, sería conveniente que el PMS registre ciertas acciones administrativas (e.g., quién aprobó X estacionamiento y cuándo, quién cambió el estado de tal reserva) en una tabla de auditoría. Los admins podrían tener acceso a estos logs si se requieren para investigar algún problema. Esto no es una “funcionalidad visible” pero es parte de las buenas prácticas al manejar datos críticos.

En resumen, las herramientas de admin garantizarán que Parkit pueda **mantener control de la plataforma** a medida que crece: asegurando que sólo estacionamientos verificados aparezcan al público, y pudiendo intervenir rápidamente ante contenidos o transacciones conflictivas.

Cabe destacar que, al igual que con los dueños, toda acción de un admin repercute en tiempo real: por ejemplo, al aprobar un estacionamiento, este pasa a estar visible en la app móvil inmediatamente; al cancelar una reserva, el conductor podría recibir una notificación enseguida, etc. Mantener esta **sincronía en tiempo real** es clave para una buena experiencia global[\[4\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Al%20conectar%20esta%20web%20al,el%20due%C3%B1o%20en%20su%20panel).
## <a name="x24506ff1a5238b9d3e1645b1265183ecdf9b9a5"></a>Integración con la App Móvil y Actualización en Tiempo Real
Uno de los mayores beneficios de utilizar Supabase como backend común es la **integración fluida entre el PMS (web) y la app móvil** de Parkit. Varios flujos de datos concurren entre ambos clientes:

- **Base de Datos Unificada:** Tanto la app Flutter como el PMS consultarán y modificarán las **mismas tablas** de PostgreSQL. No habrá discrepancias de datos, ya que no existen dos fuentes de verdad separadas. Por ejemplo, si un dueño modifica el precio por hora de su estacionamiento desde el PMS, el nuevo precio se guarda en la tabla estacionamientos y cualquier usuario que luego busque ese estacionamiento en la app verá el precio actualizado al instante. Del mismo modo, si un conductor realiza una reserva desde la app móvil, esa reserva se inserta en la tabla reservas y aparecerá inmediatamente en la vista de reservas del dueño en el PMS[\[4\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Al%20conectar%20esta%20web%20al,el%20due%C3%B1o%20en%20su%20panel). Esta consistencia es fundamental para la confianza en el sistema.
- **Subscripciones en Tiempo Real:** Configuraremos la aplicación web para suscribirse vía **WebSockets (Supabase Realtime)** a ciertas actualizaciones críticas:
- Cambios en el estado de aprobación de un estacionamiento (para que un dueño que tenga abierta la página vea cuando su estacionamiento pasó de Pendiente a Aprobado sin necesidad de refrescar).
- Nuevas reservas entrantes para el estacionamiento del propietario (podemos suscribir al canal de su estacionamiento específico, así llega una notificación interna en la web "Nueva reserva recibida" si está online).
- Actualización de cupos libres (si integráramos sensores que actualizan disponibilidad, o incluso si otro admin cambió algo, la interfaz podría reflejarlo).

Esto se logra fácilmente con la biblioteca JavaScript de Supabase: por ejemplo supabase.channel('reservas').on('postgres\_changes', ...). Gracias a esto, el PMS puede brindar una experiencia reactiva, casi como un tablero en vivo para los dueños (similar a cómo la app ya se beneficia de actualizaciones en vivo de lugares libres reportados)[\[21\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=intermedio%20podr%C3%ADa%20funcionar,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime).

- **Consistencia de Negocio:** Aseguraremos que las **reglas de negocio** se apliquen uniformemente sin importar desde dónde se produce la acción. Por ejemplo, si existe una restricción de "no permitir reservas superpuestas" o "no permitir más reservas que la capacidad", estas validaciones deben ocurrir ya sea que la reserva se cree desde la app o en un futuro desde el PMS (si permitiéramos a un dueño crear manualmente una reserva para un walk-in, por ejemplo). Estas lógicas se pueden implementar a nivel de DB (triggers o constraints) o en la capa de API. La idea es que la web PMS **no duplique lógica** que ya esté en la app, sino que consuma las mismas APIs o procedimientos almacenados. Mantendremos documentación centralizada de los endpoints y reglas actuales (del análisis del repo móvil) para replicar comportamientos cuando haga falta.
- **Mantenimiento de Experiencia Separada pero Conectada:** Aunque comparten datos, la app móvil y el PMS tienen propósitos diferentes y la UI lo reflejará. Sin embargo, habrá puntos de contacto: por ejemplo, tras aprobarse un estacionamiento, quizá la app móvil (en el perfil del usuario dueño) podría ahora mostrar opciones extra, o podría invitarlo a usar la web para funciones avanzadas. Podríamos implementar pequeños *deep links* o mensajes: *"Para administrar detalles avanzados de tu estacionamiento, accede al portal web"*.
- **Integraciones Externas:** Algunos servicios externos interactúan con Parkit:
- **Mercado Pago:** El flujo de pago involucra redirecciones web incluso desde la app móvil (la app probablemente abre un WebView o navegador para el checkout). En el PMS, los dueños no necesitan abrir eso, pero sí el OAuth. Aseguraremos que tras vincular la cuenta, los tokens se guarden correctamente y el backend de pagos use esos tokens tanto si la reserva la inicia un usuario móvil como si (hipotéticamente) un admin crea una reserva manual. Además, implementaremos **webhooks de Mercado Pago** para enterarnos de pagos aprobados, etc., que deberán actualizar nuestra base en tiempo real. Estos webhooks pueden atenderlos las mismas funciones serverless mencionadas, actualizando el estado de una reserva a "pagada" cuando llegue la confirmación, por ejemplo.
- **IZI Park u otros sensores (futuro):** Si en algún momento se integran fuentes automáticas de disponibilidad (sensores IoT en cocheras), estas integraciones probablemente enviarán datos a nuestro backend (vía una API). Lo previsto es que actualicen directamente campos en la base (por ejemplo, una tabla de ocupacion\_actual por estacionamiento). Gracias al diseño unificado, tanto la app como el PMS reflejarán esos cambios en tiempo real[\[20\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=en%20cada%20momento%20,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime). En la planificación actual, esto es un aspecto a tener en cuenta para que el diseño de la base de datos y la arquitectura del PMS no lo impidan en el futuro.

En conclusión, el PMS estará **estrechamente integrado con el ecosistema Parkit**, usando el mismo backend para lograr que todas las partes (conductores, spotters, propietarios, admins) vean un **estado consistente del sistema en todo momento[**\[4\]**](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Al%20conectar%20esta%20web%20al,el%20due%C3%B1o%20en%20su%20panel)**. Esto mejora la confiabilidad (un dato único fuente) y reduce complejidad al no tener que sincronizar bases distintas.
## <a name="plan-de-desarrollo-por-fases"></a>Plan de Desarrollo por Fases
Para implementar el PMS de forma ordenada, proponemos dividir el trabajo en fases iterativas. Cada fase produce un subconjunto funcional que puede probarse e integrarse con el resto. A grandes rasgos, las fases serían:

1. **Fase 0 – Análisis y Preparación:** Revisión final de la estructura de la base de datos actual (tablas estacionamientos, reservas, usuarios, kyc\_submissions, etc.) para confirmar qué campos existen y si se requieren migraciones. Configuración del nuevo repositorio **parkit-pms** (por ejemplo) e instalación inicial del proyecto con Next.js + TS. Configurar conexión a Supabase (URL, keys) y probar una consulta básica desde la web. Definir en Supabase los **schemas** o migraciones iniciales que necesitaremos: por ejemplo, agregar columnas de pisos y capacidad\_por\_piso en estacionamientos si no existen, o crear una tabla/vista para disponibilidad manual. Preparar también las credenciales de desarrollo (MercadoPago sandbox keys, etc.).
1. **Fase 1 – Autenticación y Roles:** Implementar el flujo de login/logout en la aplicación web utilizando Supabase Auth (puede usarse la librería @supabase/supabase-js para integrar el OAuth magic link o email/password). Crear una página de **Login** sencilla y proteger las rutas internas para solo acceso autenticado. Verificar en la sesión el rol del usuario:
1. Si es admin (según email o metadata provisionalmente), redirigir al dashboard admin.
1. Si es propietario (por defecto cualquier usuario normal se tratará como propietario potencial), redirigir a su dashboard de dueño.

En esta fase, simplemente mostrar un placeholder de “Bienvenido, [nombre] (Admin/Dueño)” para comprobar roles. Configurar las reglas RLS necesarias: por ejemplo, extender la policy de estacionamientos para permitir que los admins vean todo (inicialmente, se puede omitir y usar servicio, pero se decide aquí). **Criterio de done:** Login funcional, roles reconocidos, estructura de menú condicional renderizándose.

1. **Fase 2 – Panel “Mis Estacionamientos” (Dueño):** Desarrollar la sección para propietarios listar sus estacionamientos. Llamar desde el frontend a Supabase (RPC o query) para obtener estacionamientos donde propietario\_id = user\_id y es\_marketplace = true[\[29\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L184-L191). Mostrar en una lista/tabla con columnas: Foto principal, Nombre, Dirección, Estado (Pendiente/Aprobado), Activo (on/off), etc. Incluir un botón “+ Nuevo Estacionamiento”. Esta pantalla debe tener capacidad de **pull-to-refresh** o recarga fácil, ya que el dueño podría quedarse esperando aprobación (tal vez implementemos realtime subscription aquí también, para cambios de verificación). Preparar también la página de **Detalle/Edición de Estacionamiento**: al hacer clic en uno existente, mostrar todos sus campos en modo lectura inicialmente (se implementará edición en fase posterior). Esto sienta las bases de navegación. **Criterio de done:** Un dueño autenticado puede ver la lista real de estacionamientos que tiene (aunque sea vacío si no creó ninguno), y navegar a un formulario de creación.
1. **Fase 3 – Creación y Edición de Estacionamiento:** Implementar el **formulario de registro de estacionamiento** completo en la web. Esto incluye las secciones: Selección de tipo (privado, comercial, etc.) si aplica, carga de datos básicos (nombre, dirección – aquí podemos integrar la API de Google Places para autocompletar direcciones para mejorar UX), horarios de atención, características con checkboxes/chips (seguridad, cubierto, etc.), capacidad/pisos, precio por hora, etc.[\[6\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Registro%20y%20perfil%20de%20estacionamiento%3A,de%20ah%C3%AD%20el%20campo%20verificado)[\[15\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Mapa%20de%20plantas%20y%20espacios%3A,aunque%20eso%20es%20bastante). También integrar la **subida de fotos**: permitir al usuario seleccionar múltiples imágenes, mostrarlas en preview, y al enviar subir cada archivo al bucket Supabase Storage (usando supabase storage JS). Aplicar las mismas restricciones de cantidad que la app (3 a 10 fotos, quizás con tamaño máximo). Validar todos los campos obligatorios. Al hacer Submit, llamar al servicio (podemos crear un **RPC (Remote Procedure Call)** en Supabase o usar la librería directamente para insertar en varias tablas):
1. Insertar en estacionamientos con propietario\_id = user\_id, es\_marketplace = true, activo = false, verificado = false y demás datos (muchos van al campo JSON detalles quizás, según implementación móvil[\[30\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L162-L169)).
1. Insertar en kyc\_submissions o datos\_fiscales según tipo, **si** no se hubiera hecho antes. *Nota:* Si el flujo web sustituye al de la app, necesitaremos también permitir llenar KYC en web. Podríamos dividir: si es cochera privada y el user no tiene KYC aprobado aún, antes del formulario principal pedimos KYC (similar a app: subir DNI, etc.)[\[31\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L22-L31); si es comercial, pedir CUIT y datos fiscales[\[28\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L26-L34). Para no complicar, podríamos requerir que use la app para KYC, pero mejor experiencia es ofrecer todo en web también. Esta sub-función podría ser grande, quizás se implementa justo después del formulario principal en la misma fase o en una fase separada.
1. Insertar fotos subidas en la tabla o enlazarlas en el JSON de detalles del estacionamiento.

Tras creación, actualizar la lista "Mis Estacionamientos" para que aparezca el nuevo en estado Pendiente. **Criterio de done:** Un dueño puede completar todo el proceso de registrar un estacionamiento vía web, y los datos se reflejan en Supabase correctamente (podemos verificar que el registro aparece con estado pendiente, etc.). Debe manejarse también el flujo de **error/validación** (por ej., si falta un campo, si falla upload, etc.).

1. **Fase 4 – Módulo de Aprobación (Admin):** Mientras los dueños empiezan a cargar estacionamientos, necesitamos el panel admin para gestionarlos. Implementar la página "Administración" visible solo a admins:
1. **Subsección “Pendientes de Aprobación”:** realizar una consulta a Supabase por estacionamientos verificado = false y es\_marketplace = true. (Posiblemente filtrar también por activo=false para capturar los nuevos; aunque un dueño podría crear múltiples y activar sólo cuando verificado, pero en fin). Listarlos con info básica y ordenar por fecha de creación.
1. Permitir al admin hacer clic en uno para ver su detalle completo. Aquí reusamos componentes del formulario de creación pero en modo solo lectura para revisar la info. Mostrar enlaces a archivos de fotos/KYC para verlos en tamaño grande (quizás abrir en una nueva pestaña o modal de imagen).
1. Añadir botones **Aprobar** y **Rechazar**. Al aprobar:
   - Ejecutar un update en estacionamientos setting verificado=true, activo=true.
   - Update en kyc\_submissions/datos\_fiscales a estado aprobado (si aplicable).
   - Disparar envío de email de aprobación.
   - Registrar quién aprobó (p.ej., guardar aprobado\_por = admin\_user\_id y timestamp en alguna columna o en una tabla de logs).
1. Al rechazar: similar, marcar verificado=false y quizá dejar activo=false (ya estaba), y almacenar motivo de rechazo en una columna o tabla de notificaciones. Enviar correo de rechazo con el comentario.
1. Después de aprobar/rechazar, remover ese item de la lista de pendientes (o marcarlo como resuelto).
1. **Subsección “Todos los estacionamientos” (o varias pestañas):** El admin debería también tener una vista combinada de todos, con capacidad de filtrar por estado. Esto podría hacerse en la misma página, con pestañas "Pendientes", "Aprobados", "Rechazados", para no complicar la navegación. La pestaña "Aprobados" listaría los verificados (activos), donde el admin podría hacer clic si necesita editar o suspender alguno.
1. Asegurar que estos listados están paginados si hay muchos registros. Supabase permite paginar fácilmente con range.

**Criterio de done:** Un admin logueado puede ver los estacionamientos pendientes reales, aprobar o rechazar, y esos cambios reflejarse en la base. Por ejemplo, tras aprobar, al consultar desde psql el record debe estar actualizado. Idealmente, probar end-to-end: dueño crea -> admin aprueba -> dueño ve el cambio en su cuenta (lo cual implica también implementar la notificación o al menos la visualización del estado cambiado, puede probarlo refrescando su lista).

1. **Fase 5 – Gestión de Reservas (Dueño):** Ahora implementamos la sección de **Reservas** para propietarios. Dentro del dashboard de un estacionamiento (o general si decidimos consolidar), añadir una pestaña o menú "Reservas". Al entrar, hacer query a reservas filtrando por estacionamiento(s) del propietario. Posiblemente necesitaremos un índice o consulta que primero obtenga los IDs de estacionamiento del user, luego pida las reservas correspondientes. Mostrar en una tabla o lista con columnas: Fecha/hora, usuario (nombre o alias), estado (Ej: confirmada, pendiente pago, cancelada), código. Se pueden resaltar las reservas próximas (ej: las de hoy/tomorrow).

Implementar acciones: - **Confirmar llegada (Check-in):** podría ser un botón "Marcar como ingresado" para reservas que estén pendientes de check-in. Esto podría simplemente cambiar un campo estado = "en\_curso" o similar. Si no hay tal campo, podríamos agregarlo (por ahora, tal vez las reservas solo tienen pendiente/confirmada, etc., se puede extender). - **Cancelar reserva:** para casos especiales. Hacer update estado = "cancelada" y idealmente iniciar flujo de reembolso si es después del pago (eso último tal vez manual). - **No-show:** un botón disponible después de que pase la hora si nunca se confirmó. Cambia estado a "no\_show". Esto puede tener lógica de penalización en el futuro, pero por ahora es informativo.

Debemos asegurarnos de actualizar disponibilidad cuando se hacen estos cambios: por ejemplo, si se cancela una reserva, el espacio queda libre, por lo que podríamos incrementar el contador de libres (esto podría estar automatizado por un trigger en DB o simplemente confiar en que la vista estacionamientos\_disponibles lo calcule restando reservas activas).

También, mostrar detalles ampliados: al hacer click en una reserva, podría abrirse un modal con info completa: vehículo del usuario (tal vez Parkit registra el modelo/patente del auto reservado), contacto del usuario (por si necesita llamarlo), etc.

**Criterio de done:** Un dueño puede visualizar todas sus reservas y realizar al menos la acción de cancelación o confirmación. Los cambios se reflejan en la base (y podrían ser vistos por un admin en su panel de reservas global).

1. **Fase 6 – Dashboard y Métricas:** Implementar la pantalla de **Dashboard** tanto para propietarios (enfocado a su(s) estacionamiento(s)) como para admin (global). Para propietarios, como se describió, mostrar KPIs y gráficos relevantes a sus datos[\[26\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Dashboard%20y%20m%C3%A9tricas%3A%20El%20PMS,propietario%20pueda%20mejorar%20su%20servicio). Esto puede involucrar nuevas consultas agregadas:
1. Contar reservas del último mes, comparar con mes anterior (para tendencia).
1. Calcular ocupación: podríamos estimar ocupación = (reservas\_horas / total\_horas\_disponibles) \*100 en un periodo.
1. Listar las últimas reseñas con rating.

Usar librerías como Chart.js o Recharts para los gráficos. Asegurar que todo se recalcula correctamente si los datos cambian (posiblemente no es tan crítico en tiempo real, puede ser on load o con refresh manual).

Para el **Dashboard Admin**, mostrar métricas globales como se indicó. Esto quizás requiere más trabajo de back (ej. sumar todas las comisiones de Parkit). Podemos crear **vistas SQL** para simplificar, por ejemplo una vista resumen\_global que la consultamos directamente. Sino, hacer varias consultas separadas (Supabase permite procedimientos almacenados en PG, podría ser útil encapsular cálculos).

**Criterio de done:** Se visualizan correctamente datos estadísticos representativos (incluso si la base de test tiene pocos datos, se verifica con algunos registros dummy). Ambos tipos de dashboard están accesibles según rol.

1. **Fase 7 – Integración de Pago y Perfil:** Completar la **integración de Mercado Pago OAuth** en la web. Agregar en el perfil del propietario (o sección pagos) un botón **"Conectar cuenta de Mercado Pago"**. Al hacer click, redirige al URL de autorización de MercadoPago (client\_id y redirect URI configurados). Implementar una página o ruta /mercadopago-callback en Next.js para recibir el code y state. Desde esa ruta, llamar a la función serverless (o directamente desde backend) para intercambiar el code por access\_token/refresh\_token usando las credenciales secretas (almacenadas en el servidor). Actualizar la base: ya existe un lugar para guardar estos tokens y el user\_id de MercadoPago[\[32\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L102-L109)[\[33\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L104-L112). Una vez hecho, actualizar la UI para indicar "Cuenta conectada". Probar este flujo en sandbox.

También, revisar el manejo de pagos en reservas: si aún no está implementado, asegurarse que cuando un usuario hace checkout (en la app) y completa pago, la reserva pase a estado confirmado/pagado. Esa confirmación idealmente la recibiremos por webhook. Configurar un **Webhook endpoint** (puede ser una API route protegida) que reciba notificaciones de MercadoPago sobre pagos, verificar la firma y luego actualizar la reserva en DB. Esto es backend puro, pero es parte de tener un sistema de pagos sólido.

**Criterio de done:** Un propietario puede vincular su cuenta MercadoPago desde el PMS y los tokens se almacenan correctamente; además, la app (o un script de prueba simulando una reserva pagada) puede activar el webhook y el sistema reacciona. Esto completa la cadena financiera.

1. **Fase 8 – Notificaciones y Pulido Final:** Implementar los envíos de **emails de notificación** para los eventos clave (usando Supabase email o un servicio externo como SendGrid integrable). Ej: aprobación de estacionamiento, reserva creada/cancelada. También revisar la UI/UX en general: aseguranos de que todas las cadenas de texto estén en español claro, añadir instrucciones donde sea necesario (por ej., en formulario de registro de estacionamiento, guiar sobre formatos de CUIT, etc., como se hizo en la app[\[34\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L194-L200)). Verificar **responsividad** (el PMS podría ser usado en tablets, etc., así que debe verse bien al menos en pantallas medianas; en móviles no es prioritario optimizar). Ejecutar pruebas integrales con usuarios simulados:
1. Caso de uso completo: usuario crea cuenta -> registra estacionamiento -> admin aprueba -> usuario recibe mail -> conductor reserva vía app -> dueño ve la reserva -> conductor paga -> dueño ve pago reflejado -> dueño marca no-show, etc.
1. Asegurar que no hay fallas de permisos (intentar que un usuario normal acceda a rutas admin, etc.).

Finalmente, preparar la documentación para despliegue (variables de entorno, configuraciones necesarias, como las mencionadas en la guía rápida[\[35\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L101-L109)[\[36\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L279-L287)). Desplegar a producción.

1. **Fase 9 – Mejoras Futuras (Post-MVP):** Una vez en producción, se pueden planear iteraciones adicionales:
   - Implementar **mapeo visual de plazas** (dibujar el plano del estacionamiento y marcar plazas individuales).
   - Integrar **sensores de ocupación** (recibiendo datos automáticos para actualizar disponibilidad sin intervención manual)[\[20\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=en%20cada%20momento%20,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime).
   - Desarrollar un **módulo de analytics más avanzado** con exportación de datos, comparativas históricas, etc.
   - Crear una **app móvil o modo responsivo para dueños** que prefieran gestionar desde su smartphone (esto podría ser un modo dentro de la misma app Parkit, pero reutilizando las APIs creadas).
   - Agregar **funcionalidad de mensajería** entre conductores y dueños si se necesitara coordinar detalles de la reserva, con la posibilidad de monitoreo por admins.
   - Internacionalizar el sistema si Parkit se expande a otros países (soporte multi-idioma, multimoneda en pagos, etc.).

Cada fase descrita arriba construye sobre la anterior, permitiendo probar e integrar partes críticas temprano (especialmente la aprobación admin que es clave antes de escalar el onboarding de parkings). Es importante también involucrar feedback real de algunos usuarios propietarios piloto y del equipo de operaciones durante el desarrollo para ajustar las pantallas a su flujo de trabajo.
## <a name="conclusión"></a>Conclusión
El **Plan propuesto para el PMS** abarca la creación de una aplicación web robusta, usando un stack moderno (Next.js/React, Supabase) para brindar a Parkit la capacidad de escalar su negocio de estacionamientos privados. Hemos detallado las funcionalidades esenciales: desde el registro y gestión de estacionamientos por parte de los dueños, hasta las herramientas de control y métricas para administradores[\[22\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Gesti%C3%B3n%20de%20reservas%3A%20El%20propietario,57%5D%2C%20vinculada%20a%20su%20estacionamiento)[\[37\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Dashboard%20y%20m%C3%A9tricas%3A%20El%20PMS,propietario%20pueda%20mejorar%20su%20servicio). Siguiendo este plan, Parkit podrá ofrecer una experiencia completa y sincronizada a todos los actores (conductores, spotters, propietarios y staff) dentro de su ecosistema[\[2\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=En%20esencia%2C%20esta%20aplicaci%C3%B3n%20web,de%20cada%20parking%20por%20desarrolladores)[\[4\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Al%20conectar%20esta%20web%20al,el%20due%C3%B1o%20en%20su%20panel), logrando así expandir el marketplace de estacionamientos sin perder calidad ni control.

Con este PMS, los dueños tendrán autonomía para administrar sus cocheras en la plataforma y los conductores encontrarán siempre información actualizada y confiable, mientras el equipo Parkit mantiene la supervisión necesaria. En definitiva, es un paso fundamental para convertir a Parkit en un servicio integral de estacionamientos inteligentes, cubriendo tanto la faceta móvil de los usuarios finales como la faceta web de administración de la oferta. ¡Manos a la obra con el desarrollo de este PMS!

-----
<a name="citations"></a>[\[1\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Este%20nuevo%20sistema%20web%20actuar%C3%A1,analizado%20y%20los%20objetivos%20mencionados) [\[2\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=En%20esencia%2C%20esta%20aplicaci%C3%B3n%20web,de%20cada%20parking%20por%20desarrolladores) [\[3\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=reservas%2C%20pagos%2C%20etc,brindar%20a%20todos%20los%20actores) [\[4\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Al%20conectar%20esta%20web%20al,el%20due%C3%B1o%20en%20su%20panel) [\[5\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=match%20at%20L390%20ver%2Feditar%20sus,62) [\[6\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Registro%20y%20perfil%20de%20estacionamiento%3A,de%20ah%C3%AD%20el%20campo%20verificado) [\[15\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Mapa%20de%20plantas%20y%20espacios%3A,aunque%20eso%20es%20bastante) [\[16\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Esto%20podr%C3%ADa%20ser%20sencillo%20,aunque%20eso%20es%20bastante) [\[17\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=planea%20mostrar%20hasta%20qu%C3%A9%20nivel,aunque%20eso%20es%20bastante) [\[18\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Actualizaci%C3%B3n%20de%20disponibilidad%3A%20Si%20no,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime) [\[19\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=match%20at%20L292%20la%20DB,tiene%20un%20registro%20rico%20en) [\[20\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=en%20cada%20momento%20,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime) [\[21\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=intermedio%20podr%C3%ADa%20funcionar,mostrar%C3%A1%20al%20instante%20v%C3%ADa%20realtime) [\[22\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Gesti%C3%B3n%20de%20reservas%3A%20El%20propietario,57%5D%2C%20vinculada%20a%20su%20estacionamiento) [\[23\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Gesti%C3%B3n%20de%20reservas%3A%20El%20propietario,o%20cancelar%20reservas%20si%20es) [\[24\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Finanzas%20y%20pagos%3A%20Integrar%20la,ser%C3%ADa%20%C3%BAtil%20para%20la%20administraci%C3%B3n) [\[25\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=match%20at%20L384%20las%20reservas,est%C3%A1) [\[26\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Dashboard%20y%20m%C3%A9tricas%3A%20El%20PMS,propietario%20pueda%20mejorar%20su%20servicio) [\[37\]](file://file_00000000766c71f4a1caed79d04f102d#:~:text=Dashboard%20y%20m%C3%A9tricas%3A%20El%20PMS,propietario%20pueda%20mejorar%20su%20servicio) Análisis del Repo de Parkit y Funcionalidades Actuales.docx

<file://file_00000000766c71f4a1caed79d04f102d>

[\[7\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L82-L91) [\[8\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L94-L101) [\[10\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L48-L52) [\[27\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L24-L32) [\[28\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L26-L34) [\[29\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L184-L191) [\[31\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L22-L31) [\[34\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L194-L200) [\[35\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md#L101-L109) GUIA\_RAPIDA\_PROPIETARIOS.md

<https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/GUIA_RAPIDA_PROPIETARIOS.md>

[\[9\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L160-L168) [\[11\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L231-L239) [\[12\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L168-L171) [\[13\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L225-L234) [\[14\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L187-L194) [\[30\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L162-L169) [\[32\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L102-L109) [\[33\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L104-L112) [\[36\]](https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md#L279-L287) IMPLEMENTACION\_PROPIETARIOS\_PARKING.md

<https://github.com/juanfcastropiccolo/parkit/blob/d3e79db4e1ce0c8e7d977e97badc1ba34ae100af/documentation/IMPLEMENTACION_PROPIETARIOS_PARKING.md>
